
#include "GraphWriter.hpp"

#include <algorithm>
#include <iostream>
#include <unordered_map>

using std::unordered_map;
using std::cout;
using std::flush;
using std::endl;

GraphWriter::GraphWriter()
{
}

void GraphWriter::writeGraph(vector<Vertex>& vertices, unordered_set<Edge>& edges,
    string fout)
{
  writeBasics(vertices.size(), edges.size());
  writeVertices(vertices);
  writeEdges(edges);

  flush(fout);
}

void GraphWriter::writeBasics(int numvertices, int numedges) 
{
  XMLElement* gexf = _doc.NewElement("gexf");
  XMLElement* meta = _doc.NewElement("meta");
  XMLElement* creator = _doc.NewElement("creator");
  XMLElement* description = _doc.NewElement("description");
  XMLElement* graph = _doc.NewElement("graph");
  XMLElement* nodes = _doc.NewElement("nodes");
  XMLElement* edges = _doc.NewElement("edges");

  XMLText* creatorText = _doc.NewText("CrowGenCpp");
  XMLText* descriptionText = _doc.NewText("generated by CrowGenCpp");

  _doc.InsertEndChild(gexf);
  gexf->InsertEndChild(meta);
  gexf->InsertEndChild(graph);
  meta->InsertEndChild(creator);
  meta->InsertEndChild(description);
  graph->InsertEndChild(nodes);
  graph->InsertEndChild(edges);
  creator->InsertEndChild(creatorText);
  description->InsertEndChild(descriptionText);

  gexf->SetAttribute("xmlns", "http://www.gexf.net/1.2draft");
  gexf->SetAttribute("xmlns:viz", "http://www.gexf.net/1.2draft/viz");
  gexf->SetAttribute("version", "1.2");

  graph->SetAttribute("defaultedgetype","undirected");
  graph->SetAttribute("idtype","string");
  graph->SetAttribute("mode","dynamic");
  graph->SetAttribute("timeformat","integer");

  nodes->SetAttribute("count", numvertices);
  edges->SetAttribute("count", numedges);
}

void GraphWriter::writeVertices(vector<Vertex>& vertices) 
{
  XMLElement* nodes = _doc.FirstChildElement("gexf")->FirstChildElement("graph")
    ->FirstChildElement("nodes");

  sort(vertices.begin(), vertices.end());

  cout << "Writing vertices." << endl;
  for (size_t i = 0; i < vertices.size(); i++)
  {
    cout << "\rVertex " << i << "\tof " << vertices.size();
    cout.flush();
    Vertex v = vertices.at(i);
    XMLElement* node = _doc.NewElement("node");
    XMLElement* spells = _doc.NewElement("spells");
    XMLElement* spell = _doc.NewElement("spell");
    XMLElement* viz_position = _doc.NewElement("viz:position");

    nodes->InsertEndChild(node);
    node->InsertEndChild(spells);
    node->InsertEndChild(viz_position);
    spells->InsertEndChild(spell);

    node->SetAttribute("id", v.id());
    node->SetAttribute("label", v.label());

    viz_position->SetAttribute("x", v.location().x());
    viz_position->SetAttribute("y", v.location().y());

    spell->SetAttribute("start", v.start());
    spell->SetAttribute("end", v.end());
  }
  cout << endl;
}

void GraphWriter::writeEdges(unordered_set<Edge>& edges) 
{
  XMLElement* edgesxml = _doc.FirstChildElement("gexf")->FirstChildElement("graph")
    ->FirstChildElement("edges");

  cout << "Writing edges." << endl;
  long i = 0;
  for (unordered_set<Edge>::iterator it = edges.begin(); it != edges.end(); it++)
  {
    cout << "\rEdge " << i++ << "\tof " << edges.size();
    cout.flush();
    Edge e = *it;
    XMLElement* edge = _doc.NewElement("edge");
    XMLElement* spells = _doc.NewElement("spells");

    edgesxml->InsertEndChild(edge);
    edge->InsertEndChild(spells);

    edge->SetAttribute("id", e.id().c_str());
    edge->SetAttribute("source", e.source().id());
    edge->SetAttribute("target", e.target().id());
    edge->SetAttribute("type", e.type().c_str());

    for (pair<unsigned int, unsigned int> p : e.lifetimes())
    {
      writeEdgeSpell(p, spells);
    }
  }
  cout << endl;
}

void GraphWriter::writeEdgeSpell(pair<unsigned int, unsigned int>& lifetime,
    XMLElement* spellsElement)
{
  XMLElement* spell = _doc.NewElement("spell");
  spell->SetAttribute("start", lifetime.first);
  spell->SetAttribute("end", lifetime.second);
  spellsElement->InsertEndChild(spell);
}

void GraphWriter::flush(string fout)
{
  _doc.SaveFile(fout.c_str());
}
